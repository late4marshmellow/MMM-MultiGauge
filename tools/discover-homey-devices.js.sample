#!/usr/bin/env node
const http = require("node:http");
const fs = require("node:fs");
const path = require("node:path");

// ============================================================================
// MANUAL CONFIGURATION (Optional - leave empty to auto-load from config.js)
// ============================================================================
// NOTE: This tool uses Homey's HTTP API to discover devices and capabilities.
// MQTT is used by MMM-MultiGauge for real-time updates, but this tool needs
// the Homey API token to fetch the initial device list.
//
// RECOMMENDED: Add these to your MMM-MultiGauge config in config.js:
//   config: {
//     token: "your-api-token-here",
//     tokenType: "Bearer",
//     mqtt: { url: "mqtt://192.168.10.35:1883", ... },
//     api: { method: "GET", headers: {}, ... }
//   }
// This way you set the token once and both the module and tool can use it.

const MANUAL_HOMEY_IP = "";    // e.g., "192.168.10.35" or leave empty
const MANUAL_HOMEY_TOKEN = ""; // e.g., "your-api-token-here" or leave empty

// ============================================================================
// CONFIGURATION - Try to load from config.js, or use manual values above
// ============================================================================
function loadConfigFromMagicMirror() {
  try {
    const possiblePaths = [
      path.join(__dirname, '../../../config/config.js'),  // From modules/MMM-MultiGauge/tools/
      path.join(__dirname, '../../config/config.js'),
      path.join(process.cwd(), 'config/config.js'),
      path.join(process.env.HOME, 'MagicMirror/config/config.js')
    ];

    for (const configPath of possiblePaths) {
      if (fs.existsSync(configPath)) {
        const configContent = fs.readFileSync(configPath, 'utf8');
        const globalHomeyAPI = configContent.match(/const\s+Homey_API\s*=\s*["']([^"']+)["']/);
        const globalHomeyToken = configContent.match(/const\s+homeyToken\s*=\s*["']([^"']+)["']/);
        let homeyIP = null;
        let homeyToken = null;
        const mqttMatch = configContent.match(/mqtt:\s*{\s*url:\s*["']mqtt:\/\/([^:"']+)/);
        if (mqttMatch) {
          homeyIP = mqttMatch[1];
        }
        const tokenMatchNew = configContent.match(/(?:^|\s)token:\s*["']([^"']+)["']/);
        const tokenMatchOld = configContent.match(/homeyToken:\s*["']([^"']+)["']/);
        if (tokenMatchNew) {
          homeyToken = tokenMatchNew[1];
        } else if (tokenMatchOld) {
          homeyToken = tokenMatchOld[1];
        }
        const finalToken = homeyToken || (globalHomeyToken ? globalHomeyToken[1] : null) || (globalHomeyAPI ? globalHomeyAPI[1] : null);
        
        if (finalToken || homeyIP) {
          console.log(`✓ Found config at: ${configPath}`);
          if (homeyIP) {
            console.log(`✓ Using Homey IP from MMM-MultiGauge MQTT config: ${homeyIP}`);
          }
          if (homeyToken) {
            console.log(`✓ Using Homey token from MMM-MultiGauge config`);
          }
          return {
            token: finalToken,
            ip: homeyIP
          };
        }
      }
    }
  } catch (error) {
  }
  return { token: null, ip: null };
}

const args = process.argv.slice(2);
let homeyIPOverride = null;
let homeyTokenOverride = null;

for (let i = 0; i < args.length; i++) {
  if (args[i] === '--ip' && args[i + 1]) {
    homeyIPOverride = args[i + 1];
    args.splice(i, 2);
    i--;
  } else if (args[i] === '--token' && args[i + 1]) {
    homeyTokenOverride = args[i + 1];
    args.splice(i, 2);
    i--;
  }
}

const configFromFile = loadConfigFromMagicMirror();

const HOMEY_IP = homeyIPOverride || MANUAL_HOMEY_IP || configFromFile.ip;
const HOMEY_TOKEN = homeyTokenOverride || MANUAL_HOMEY_TOKEN || configFromFile.token;

if (!HOMEY_IP || !HOMEY_TOKEN) {
  console.error("\n❌ Error: Homey IP and API token are required!");
  console.error("\nOptions:");
  console.error("  1. Edit MANUAL_HOMEY_IP and MANUAL_HOMEY_TOKEN at the top of this file");
  console.error("  2. Ensure MMM-MultiGauge is configured in config.js with MQTT url and Homey_API");
  console.error("  3. Use command-line arguments:");
  console.error("     node discover-homey-devices.js --ip 192.168.10.35 --token YOUR_TOKEN [filters...]");
  console.error("\nExample:");
  console.error('  node discover-homey-devices.js --ip 192.168.10.35 --token "abc123..." "electricity*"\n');
  process.exit(1);
}

// ============================================================================
// SEARCH FILTERS (customize as needed)
// ============================================================================
const filters = {
  // Search by device name (case-insensitive, partial match)
  name: args[0] || "",

  // Search by capability (e.g., "measure_power", "meter_", "temperature")
  capability: args[1] || "",

  // Search by zone name
  zone: args[2] || "",

  // Search by unit/postfix (e.g., "W", "Wh", "°C", "kWh")
  postfix: args[3] || "",

  // Only show devices with specific capability types
  onlyCapabilities: [], // e.g., ["measure_power", "meter_consumption", "measure_temperature"]

  // Exclude devices by name pattern
  exclude: [], // e.g., ["test", "old"]

  // Show only devices in specific zones
  onlyZones: [] // e.g., ["Living Room", "Kitchen"]
};

async function fetchHomeyDevices () {
  return new Promise((resolve, reject) => {
    const options = {
      hostname: HOMEY_IP,
      path: "/api/manager/devices/device",
      method: "GET",
      headers: {
        Authorization: `Bearer ${HOMEY_TOKEN}`
      }
    };

    http.get(options, (res) => {
      let data = "";
      res.on("data", (chunk) => {
        data += chunk;
      });
      res.on("end", () => {
        try {
          resolve(JSON.parse(data));
        } catch (e) {
          reject(new Error(`Failed to parse JSON: ${e.message}`));
        }
      });
    }).on("error", reject);
  });
}

function wildcardToRegex(pattern) {
  if (pattern.startsWith('/') && pattern.includes('/', 1)) {
    const lastSlash = pattern.lastIndexOf('/');
    const regexPattern = pattern.slice(1, lastSlash);
    const flags = pattern.slice(lastSlash + 1);
    return new RegExp(regexPattern, flags || 'i');
  }
  const escaped = pattern
    .replace(/[.+^${}()|[\]\\]/g, '\\$&')
    .replace(/\*/g, '.*')
    .replace(/\?/g, '.');
  
  return new RegExp(`^${escaped}$`, 'i');
}

function matchesPattern(text, pattern) {
  if (!pattern) return true;
  
  if (pattern.includes('*') || pattern.includes('?') || pattern.startsWith('/')) {
    const regex = wildcardToRegex(pattern);
    return regex.test(text);
  }
  
  return text.toLowerCase().includes(pattern.toLowerCase());
}

function matchesFilters (device, zoneName, capabilitiesObj) {
  if (filters.name && !matchesPattern(device.name, filters.name)) {
    return false;
  }

  if (filters.zone && !matchesPattern(zoneName, filters.zone)) {
    return false;
  }

  if (filters.exclude.some((pattern) => device.name.toLowerCase().includes(pattern.toLowerCase()))) {
    return false;
  }

  if (filters.onlyZones.length > 0 && !filters.onlyZones.includes(zoneName)) {
    return false;
  }

  if (filters.capability) {
    const hasCapability = Object.keys(device.capabilitiesObj || {}).some((cap) => 
      matchesPattern(cap, filters.capability)
    );
    if (!hasCapability) {
      return false;
    }
  }

  if (filters.onlyCapabilities.length > 0) {
    const hasRequiredCap = Object.keys(device.capabilitiesObj || {}).some((cap) => filters.onlyCapabilities.some((reqCap) => cap.includes(reqCap)));
    if (!hasRequiredCap) {
      return false;
    }
  }

  if (filters.postfix && capabilitiesObj) {
    const hasMatchingUnit = Object.values(capabilitiesObj).some((cap) => {
      const unit = cap.units || "";
      return matchesPattern(unit, filters.postfix);
    });
    if (!hasMatchingUnit) {
      return false;
    }
  }

  return true;
}

function formatCapabilityValue (cap) {
  if (cap.value === null || cap.value === undefined) {
    return "null";
  }
  if (typeof cap.value === "number") {
    return cap.value.toFixed(2);
  }
  if (typeof cap.value === "boolean") {
    return cap.value
      ? "true"
      : "false";
  }
  return String(cap.value);
}

function getCapabilityUnit (cap) {
  if (cap.units) {
    return cap.units;
  }
  const unitMap = {
    measure_power: "W",
    meter_power: "kWh",
    measure_temperature: "°C",
    measure_humidity: "%",
    measure_voltage: "V",
    measure_current: "A",
    meter_consumption: "W",
    dim: "%",
    volume_set: "%"
  };

  for (const [key, unit] of Object.entries(unitMap)) {
    if (cap.id.includes(key)) {
      return unit;
    }
  }

  return "";
}

function generateMQTTTopic (deviceId, capabilityId) {
  return `homey/devices/${deviceId}/capabilities/${capabilityId}/value`;
}

function generateGaugeConfig (device, capName, cap) {
  const unit = getCapabilityUnit(cap);
  const currentValue = typeof cap.value === "number"
    ? cap.value
    : 0;
  let maxValue = 100;
  if (capName.includes("power") || capName.includes("consumption")) {
    maxValue = 5000;
  } else if (capName.includes("temperature")) {
    maxValue = 30;
  } else if (capName.includes("humidity")) {
    maxValue = 100;
  } else if (capName.includes("voltage")) {
    maxValue = 250;
  } else if (capName.includes("current")) {
    maxValue = 20;
  }

  return {
    id: `${device.name.toLowerCase().replace(/[^a-z0-9]/g, "_")}_${capName.replace(/[^a-z0-9]/g, "_")}`,
    maxValue,
    postfix: unit,
    mqtt: {
      topic: generateMQTTTopic(device.id, capName),
      parser: "plain",
      valuePath: "value"
    }
  };
}

async function main () {
  console.log("\n╔══════════════════════════════════════════════════════════════════╗");
  console.log("║          Homey Device Discovery for MMM-MultiGauge              ║");
  console.log("╚══════════════════════════════════════════════════════════════════╝\n");
  
  console.log(`Using Homey IP: ${HOMEY_IP}`);

  if (process.argv.includes("--help") || process.argv.includes("-h")) {
    console.log("Usage: node discover-homey-devices.js [OPTIONS] [name-filter] [capability-filter] [zone-filter] [postfix-filter]\n");
    console.log("Options:");
    console.log("  --ip <address>       Override Homey IP address");
    console.log("  --token <token>      Override Homey API token");
    console.log("  -h, --help           Show this help\n");
    console.log("By default, reads IP/token from MMM-MultiGauge config in config.js\n");
    console.log("Supports wildcards (* = any chars, ? = one char) and regex (/pattern/flags)\n");
    console.log("Examples:");
    console.log("  node discover-homey-devices.js                              # Show all devices");
    console.log("  node discover-homey-devices.js power                        # Devices with \"power\" in name");
    console.log("  node discover-homey-devices.js \"electricity*\"               # Devices starting with \"electricity\"");
    console.log("  node discover-homey-devices.js \"*meter\"                     # Devices ending with \"meter\"");
    console.log("  node discover-homey-devices.js \"/^electricity/i\"           # Regex: starts with electricity");
    console.log("  node discover-homey-devices.js \"\" \"measure_*\"              # Capabilities starting with \"measure_\"");
    console.log("  node discover-homey-devices.js \"\" \"\" \"Living*\"            # Devices in zones starting with \"Living\"");
    console.log("  node discover-homey-devices.js \"\" \"\" \"\" \"W\"               # Capabilities using \"W\" unit");
    console.log("\nWith manual IP/token:");
    console.log("  node discover-homey-devices.js --ip 192.168.10.35 --token \"abc...\" \"electricity*\"");
    console.log("  node discover-homey-devices.js --ip 192.168.10.66 power\n");
    process.exit(0);
  }

  console.log(`Filters: name="${filters.name}" capability="${filters.capability}" zone="${filters.zone}" postfix="${filters.postfix}"\n`);

  try {
    console.log("Fetching devices from Homey...\n");
    const devicesData = await fetchHomeyDevices();

    const devices = Array.isArray(devicesData)
      ? devicesData
      : Object.values(devicesData);

    const filteredDevices = [];

    for (const device of devices) {
      const zoneName = device.zone?.name || "No Zone";

      if (!matchesFilters(device, zoneName, device.capabilitiesObj)) {
        continue;
      }

      filteredDevices.push({
        name: device.name,
        id: device.id,
        zone: zoneName,
        class: device.class || "unknown",
        capabilities: device.capabilitiesObj || {}
      });
    }

    if (filteredDevices.length === 0) {
      console.log("No devices found matching filters.");
      console.log("\nActive filters:");
      if (filters.name) {
        console.log(`  - Name contains: "${filters.name}"`);
      }
      if (filters.capability) {
        console.log(`  - Capability contains: "${filters.capability}"`);
      }
      if (filters.zone) {
        console.log(`  - Zone contains: "${filters.zone}"`);
      }
      process.exit(0);
    }

    console.log(`Found ${filteredDevices.length} device(s):\n`);
    console.log("═".repeat(80));

    const gaugeConfigs = [];

    for (const device of filteredDevices) {
      console.log(`\n📱 ${device.name}`);
      console.log(`   ID: ${device.id}`);
      console.log(`   Zone: ${device.zone}`);
      console.log(`   Class: ${device.class}`);
      console.log("   Capabilities:");

      const capabilities = Object.entries(device.capabilities);

      if (capabilities.length === 0) {
        console.log("      (none)");
        continue;
      }

      for (const [capName, cap] of capabilities) {
        if (filters.capability && !matchesPattern(capName, filters.capability)) {
          continue;
        }

        const value = formatCapabilityValue(cap);
        const unit = getCapabilityUnit(cap);
        const title = cap.title || capName;

        console.log(`      • ${title} (${capName}) - Current: ${value} ${unit}`.trim());

        if (typeof cap.value === "number") {
          const gaugeConfig = generateGaugeConfig(device, capName, cap);
          console.log("        {");
          console.log(`          id: "${gaugeConfig.id}",`);
          console.log(`          maxValue: ${gaugeConfig.maxValue},`);
          console.log(`          postfix: "${gaugeConfig.postfix}",`);
          console.log("          mqtt: {");
          console.log(`            topic: "${gaugeConfig.mqtt.topic}",`);
          console.log(`            parser: "${gaugeConfig.mqtt.parser}",`);
          console.log(`            valuePath: "${gaugeConfig.mqtt.valuePath}"`);
          console.log("          }");
          console.log("        },");
          gaugeConfigs.push(gaugeConfig);
        }
      }
    }

    console.log(`\n${"═".repeat(80)}`);
    console.log(`\n✓ Generated ${gaugeConfigs.length} gauge configuration(s)\n`);
  } catch (error) {
    console.error("Error:", error.message);
    process.exit(1);
  }
}

main();